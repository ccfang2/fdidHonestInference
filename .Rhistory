shiny::runApp()
shiny::runApp()
runApp()
plot(1:10, main = "My Plot")
my_saved_plot <- recordPlot()
dev.off()  # Close the graphics device
# Display it later
replayPlot(my_saved_plot)
replayPlot(my_saved_plot)
my_saved_plot
create_plot <- function() {
plot(rnorm(100), main = "Generated Plot", col = "steelblue")
}
# Store the function
my_plot_function <- create_plot
# Execute later
my_plot_function()
create_plot <- function() {
plot(rnorm(100), main = "Generated Plot", col = "steelblue")
}
# Store the function
my_plot_function <- create_plot
# Execute later
my_plot_function()
create_plot()
create_plot()
shiny::runApp()
runApp()
runApp()
LWdata$beta[,2]
LWdata$t0
runApp()
runApp()
runApp()
runApp()
# Simple for loop example
for_loop_example <- function(n) {
result <- numeric(n)
for (i in 1:n) {
result[i] <- sqrt(i) + log(i + 1)  # Some arbitrary calculation
}
return(result)
}
# foreach example (sequential mode - comparable to for loop)
foreach_example_seq <- function(n) {
foreach(i = 1:n, .combine = 'c') %do% {
sqrt(i) + log(i + 1)  # Same calculation as in for loop
}
}
# foreach example (parallel mode)
foreach_example_par <- function(n) {
foreach(i = 1:n, .combine = 'c') %dopar% {
sqrt(i) + log(i + 1)
}
}
library(foreach)
library(doParallel)
# Set up parallel backend
cl <- makeCluster(detectCores() - 1)  # Use all but one core
registerDoParallel(cl)
# Test parameters
n <- 200  # Number of iterations
test_cases <- list(
"for_loop" = function() for_loop_example(n),
"foreach_seq" = function() foreach_example_seq(n),
"foreach_par" = function() foreach_example_par(n)
)
# Run timing comparison
timings <- lapply(test_cases, function(f) {
gc()  # Garbage collect before timing
system.time(f())[["elapsed"]]
})
# Clean up parallel backend
stopCluster(cl)
# Print results
print(timings)
# Set up parallel backend
cl <- makeCluster(detectCores() - 1)  # Use all but one core
registerDoParallel(cl)
# Test parameters
n <- 500  # Number of iterations
test_cases <- list(
"for_loop" = function() for_loop_example(n),
"foreach_seq" = function() foreach_example_seq(n),
"foreach_par" = function() foreach_example_par(n)
)
# Run timing comparison
timings <- lapply(test_cases, function(f) {
gc()  # Garbage collect before timing
system.time(f())[["elapsed"]]
})
# Clean up parallel backend
stopCluster(cl)
# Print results
print(timings)
# Set up parallel backend
cl <- makeCluster(detectCores() - 1)  # Use all but one core
registerDoParallel(cl)
# Test parameters
n <- 500  # Number of iterations
test_cases <- list(
"for_loop" = function() for_loop_example(n),
"foreach_seq" = function() foreach_example_seq(n),
"foreach_par" = function() foreach_example_par(n)
)
# Run timing comparison
timings <- lapply(test_cases, function(f) {
gc()  # Garbage collect before timing
system.time(f())[["elapsed"]]
})
# Clean up parallel backend
stopCluster(cl)
# Print results
print(timings)
registerDoParallel(cl)
# Test parameters
n <- 200  # Number of iterations
test_cases <- list(
"for_loop" = function() for_loop_example(n),
"foreach_seq" = function() foreach_example_seq(n),
"foreach_par" = function() foreach_example_par(n)
)
# Run timing comparison
timings <- lapply(test_cases, function(f) {
gc()  # Garbage collect before timing
system.time(f())[["elapsed"]]
})
# Simple for loop example
for_loop_example <- function(n) {
result <- numeric(n)
for (i in 1:n) {
result[i] <- sqrt(i) + log(i + 1)  # Some arbitrary calculation
}
return(result)
}
# foreach example (sequential mode - comparable to for loop)
foreach_example_seq <- function(n) {
foreach(i = 1:n, .combine = 'c') %do% {
sqrt(i) + log(i + 1)  # Same calculation as in for loop
}
}
# foreach example (parallel mode)
foreach_example_par <- function(n) {
foreach(i = 1:n, .combine = 'c') %dopar% {
sqrt(i) + log(i + 1)
}
}
library(foreach)
library(doParallel)
# Set up parallel backend
cl <- makeCluster(detectCores() - 1)  # Use all but one core
registerDoParallel(cl)
# Test parameters
n <- 200  # Number of iterations
test_cases <- list(
"for_loop" = function() for_loop_example(n),
"foreach_seq" = function() foreach_example_seq(n),
"foreach_par" = function() foreach_example_par(n)
)
# Run timing comparison
timings <- lapply(test_cases, function(f) {
gc()  # Garbage collect before timing
system.time(f())[["elapsed"]]
})
# Clean up parallel backend
stopCluster(cl)
# Print results
print(timings)
# Simple for loop example
for_loop_example <- function(n) {
result <- numeric(n)
for (i in 1:n) {
result[i] <- sqrt(i) + log(i + 1)  # Some arbitrary calculation
}
return(result)
}
# foreach example (sequential mode - comparable to for loop)
foreach_example_seq <- function(n) {
foreach(i = 1:n, .combine = 'c') %do% {
sqrt(i) + log(i + 1)  # Same calculation as in for loop
}
}
# foreach example (parallel mode)
foreach_example_par <- function(n) {
foreach(i = 1:n, .combine = 'c') %dopar% {
sqrt(i) + log(i + 1)
}
}
library(foreach)
library(doParallel)
# Set up parallel backend
cl <- makeCluster(detectCores() - 1)  # Use all but one core
registerDoParallel(cl)
# Test parameters
n <- 500  # Number of iterations
test_cases <- list(
"for_loop" = function() for_loop_example(n),
"foreach_seq" = function() foreach_example_seq(n),
"foreach_par" = function() foreach_example_par(n)
)
# Run timing comparison
timings <- lapply(test_cases, function(f) {
gc()  # Garbage collect before timing
system.time(f())[["elapsed"]]
})
# Clean up parallel backend
stopCluster(cl)
# Print results
print(timings)
shiny::runApp()
runApp()
shiny::runApp()
runApp()
shiny::runApp()
remove.packages("fdid")
devtools::install_github("ccfang2/fdid")
shiny::runApp()
runApp()
runApp()
data(Ldata)
fdid_scb_est <- fdid_scb(beta=Ldata$beta, cov=Ldata$cov, t0=Ldata$t0)
plot(fdid_scb_est)
plot(fdid_scb_est, post.trt = T)
shiny::runApp()
runApp()
library(fdid)
data(LWdata)
fdid_scb_est <- fdid_scb(beta=LWdata$beta, cov=LWdata$cov, t0=LWdata$t0)
plot(fdid_scb_est, ta.t0=-4)
plot(fdid_scb_est, ta.t0=-1)
plot(fdid_scb_est, ta.t0=-3)
plot(fdid_scb_est, ta.t0=-3, ta.s=2)
###################################################
## Libraries
###################################################
library(HonestDiD) # remotes::install_github("asheshrambachan/HonestDiD")
library(fdid) # devtools::install_github("ccfang2/fdid")
###################################################
## Setups
###################################################
mydir <- dirname(rstudioapi::getActiveDocumentContext()$path) ## set the file path to the current file
setwd(mydir)
###################################################
## Event Study Plot
###################################################
# Data
betahat           <- LWdata_EventStudy$betahat
sigma             <- LWdata_EventStudy$sigma
timeVec           <- LWdata_EventStudy$timeVec
referencePeriod   <- LWdata_EventStudy$referencePeriod
prePeriodIndices  <- LWdata_EventStudy$prePeriodIndices
postPeriodIndices <- LWdata_EventStudy$postPeriodIndices
timeVec_0         <- c(timeVec[prePeriodIndices], referencePeriod, timeVec[postPeriodIndices])
timeVec_0         <- timeVec_0+2 # recenter the time
referencePeriod   <- 0
betahat_0         <- rep(0, length(timeVec)+1)
betahat_0[prePeriodIndices]    <- betahat[prePeriodIndices]
betahat_0[postPeriodIndices+1] <- betahat[postPeriodIndices]
sigma_0           <- matrix(0, length(timeVec)+1, length(timeVec)+1)
sigma_0[prePeriodIndices, prePeriodIndices]       <- sigma[prePeriodIndices, prePeriodIndices]
sigma_0[postPeriodIndices+1, postPeriodIndices+1] <- sigma[postPeriodIndices, postPeriodIndices]
sigma_0[prePeriodIndices, postPeriodIndices+1]    <- sigma[prePeriodIndices, postPeriodIndices]
sigma_0[postPeriodIndices+1, prePeriodIndices]    <- sigma[postPeriodIndices, prePeriodIndices]
# Bounds of CI
alpha <- 0.05
ci_upper <- betahat_0+qnorm(p=1-alpha/2)*sqrt(diag(sigma_0))
ci_lower <- betahat_0-qnorm(p=1-alpha/2)*sqrt(diag(sigma_0))
beta <- cbind(betahat_0, timeVec_0)
fdid_scb_est <- fdid::fdid_scb(beta=beta, cov=sigma_0, t0=0, n_int=16, conf.level=0.95)
par(family="Times")
plot(fdid_scb_est, ta.t0 = -1, ta.s=2, post.trt =TRUE)
data(LWdata)
fdid_scb_est <- fdid_scb(beta=LWdata$beta, cov=LWdata$cov, t0=LWdata$t0, n_int = 16)
plot(fdid_scb_est, ta.t0=-3, ta.s = 2)
par(family="Times")
plot(fdid_scb_est, ta.t0 = -1, ta.s=1.98, post.trt =TRUE)
###################################################
## Libraries
###################################################
library(HonestDiD) # remotes::install_github("asheshrambachan/HonestDiD")
library(fdid) # devtools::install_github("ccfang2/fdid")
###################################################
## Setups
###################################################
mydir <- dirname(rstudioapi::getActiveDocumentContext()$path) ## set the file path to the current file
setwd(mydir)
###################################################
## Event Study Plot
###################################################
# Data
betahat           <- LWdata_EventStudy$betahat
sigma             <- LWdata_EventStudy$sigma
timeVec           <- LWdata_EventStudy$timeVec
referencePeriod   <- LWdata_EventStudy$referencePeriod
prePeriodIndices  <- LWdata_EventStudy$prePeriodIndices
postPeriodIndices <- LWdata_EventStudy$postPeriodIndices
timeVec_0         <- c(timeVec[prePeriodIndices], referencePeriod, timeVec[postPeriodIndices])
timeVec_0         <- timeVec_0+2 # recenter the time
referencePeriod   <- 0
betahat_0         <- rep(0, length(timeVec)+1)
betahat_0[prePeriodIndices]    <- betahat[prePeriodIndices]
betahat_0[postPeriodIndices+1] <- betahat[postPeriodIndices]
sigma_0           <- matrix(0, length(timeVec)+1, length(timeVec)+1)
sigma_0[prePeriodIndices, prePeriodIndices]       <- sigma[prePeriodIndices, prePeriodIndices]
sigma_0[postPeriodIndices+1, postPeriodIndices+1] <- sigma[postPeriodIndices, postPeriodIndices]
sigma_0[prePeriodIndices, postPeriodIndices+1]    <- sigma[prePeriodIndices, postPeriodIndices]
sigma_0[postPeriodIndices+1, prePeriodIndices]    <- sigma[postPeriodIndices, prePeriodIndices]
# Bounds of CI
alpha <- 0.05
ci_upper <- betahat_0+qnorm(p=1-alpha/2)*sqrt(diag(sigma_0))
ci_lower <- betahat_0-qnorm(p=1-alpha/2)*sqrt(diag(sigma_0))
beta <- cbind(betahat_0, timeVec_0)
fdid_scb_est <- fdid::fdid_scb(beta=beta, cov=sigma_0, t0=0, n_int=16, conf.level=0.95)
par(family="Times")
plot(fdid_scb_est, ta.t0 = -1, ta.s=1.98, post.trt =TRUE)
pdf("./Plots/TA.pdf", width = 8, height = 6)
par(family="Times")
plot(fdid_scb_est, ta.t0 = -1, ta.s=1.98, post.trt =TRUE)
dev.off()
shiny::runApp()
runApp()
runApp()
shiny::runApp()
data(simulated_stagger_example)
View(simulated_nonstagger_data)
View(simulated_nonstagger_treatment)
write.csv(simulated_nonstagger_data, file="DataFormat.csv")
write.csv(simulated_nonstagger_treatment, file="TreatmentFormat.csv")
runApp()
library(fdid)
data(simulated_stagger_example)
fdid_est <- fdid(data=simulated_stagger_data, treatment=simulated_stagger_treatment)
fdid_est <- fdid(data=simulated_stagger_data, treatment=simulated_stagger_treatment)
fdid
fdid_est <- fdid(data=simulated_stagger_data, treatment=simulated_stagger_treatment)
shiny::runApp()
data(simulated_stagger_example)
View(simulated_nonstagger_data)
View(simulated_nonstagger_treatment)
class(simulated_nonstagger_data)
help_data<-simulated_nonstagger_data
help_treatment <- simulated_nonstagger_treatment
ncol(help_data)-1
colnames(help_data)[c(1, ncol(help_data)-1, ncol(help_data))] <- c("y", "t", "i")
colnames(help_treatment) <- c("i","t0")
help_treatment<- simulated_nonstagger_treatment
View(help_treatment)
help_data<- simulated_nonstagger_data
colnames(help_data)
colnames(help_treatment)[1:2]
colnames(help_data) <- c("y", "t", "i")
colnames(help_treatment)[1:2] <- c("i","t0")
sum(is.na(help_treatment$t0))==0
if (sum(is.na(help_treatment$t0))==0) stop("There must be some control units marked with NA in 't0' at 'treatment' file.")
if(!is.numeric(help_data$t)) stop("The time index in 'data' file should be numeric.")
if(!is.numeric(help_data$y)) stop("The outcome variable in 'data' file should be numeric.")
if(!all(na.omit(unique(help_treatment$t0)) %in% unique(help_data$t))) stop("The reference time in 'treatment' file should be among the time index in 'data' file.")
if(!all(na.omit(unique(help_treatment$t0)) > min(unique(help_data$t)) & na.omit(unique(help_treatment$t0)) < max(unique(help_data$t)))) stop("The reference time in 'treatment' file should be greater/less than the min/max of time index in 'data' file.")
fdid_est      <- fdid::fdid(data=help_data, treatment=help_treatment)
plot(fdid_est$beta$coef[,2], fdid_est$beta$coef[,1], type="l",
xlab="Event Time", ylab=expression(hat(beta)), family="Times")
runApp()
shiny::runApp()
shiny::runApp()
runApp()
shiny::runApp()
runApp()
shiny::runApp()
library(shiny)
shiny::runGitHub("fdidHonestInference", "ccfang2")
194/5
274/7
40*7
274+212
486+200
234/6
233+230+90+20+6*50
750*8
shiny::runApp()
runApp()
runApp()
shiny::runApp()
shiny::runApp()
library(fdid)
shiny::runApp()
shiny::runApp()
library(fdid)
shiny::runApp()
library(shiny)
shiny::runGitHub("fdidHonestInference", "ccfang2")
shiny::runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
a=c(NULL, NULL)
is.null(a)
a=c(NULL, NULL)
is.null(a)
!is.null(a)
length(is.null(a))
data(LWdata)
fdid_scb_est <- fdid_scb(beta=LWdata$beta, cov=LWdata$cov, t0=LWdata$t0)
fdid_scb_est$data$t0
is.null(c(2,NULL))
shiny::runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
shiny::runApp()
runApp()
runApp()
shiny::runApp()
shiny::runApp()
